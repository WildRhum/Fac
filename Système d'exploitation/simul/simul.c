
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

/**********************************************************
** Codage d'une instruction (32 bits)
***********************************************************/

typedef struct {
	unsigned OP: 10;  /* code operation (10 bits)  */
	unsigned i:   3;  /* nu 1er registre (3 bits)  */
	unsigned j:   3;  /* nu 2eme registre (3 bits) */
	short    ARG;     /* argument (16 bits)        */
} INST;


/**********************************************************
** definition de la memoire simulee
***********************************************************/

typedef int WORD;  /* un mot est un entier 32 bits  */

WORD mem[128];     /* memoire                       */

/**********************************************************
** Compteur d'insturction
***********************************************************/

int nbInst = 0;

/**********************************************************
** Codes associes aux instructions
***********************************************************/

#define INST_ADD	(0)
#define INST_SUB	(1)
#define INST_CMP	(2)
#define INST_IFGT   (3)
#define INST_NOP    (4)
#define INST_JUMP   (5)
#define INST_HALT   (6)
#define INST_UNKNOW (7)
#define INST_SYSC	(8)
#define INST_LOAD	(9)
#define INST_STORE	(10)

/**********************************************************
** Placer une instruction en memoire
***********************************************************/

void make_inst(int adr, unsigned code, unsigned i, unsigned j, short arg) {
	union { WORD word; INST fields; } inst;
	inst.fields.OP  = code;
	inst.fields.i   = i;
	inst.fields.j   = j;
	inst.fields.ARG = arg;
	mem[adr] = inst.word;
}


/**********************************************************
** Codes associes aux interruptions
***********************************************************/

#define INT_INIT	(1)
#define INT_SEGV	(2)
#define INT_INST	(3)
#define INT_TRACE	(4)
#define INT_CLOCK	(5)
#define INT_SYSC	(6)

/**********************************************************
** Interruption système
***********************************************************/

#define SYSC_EXIT		(0)
#define SYSC_PUTI		(1)
#define SYSC_NEW_THREAD	(2)
#define SYSC_SLEEP		(3)
#define SYSC_GETCHAR	(4)
#define SYSC_FORK		(5)

/**********************************************************
** Le Mot d'Etat du Processeur (PSW)
***********************************************************/

typedef struct PSW {    /* Processor Status Word */
	WORD PC;        	/* Program Counter */
	WORD SB;        	/* Segment Base */
	WORD SS;        	/* Segment Size */
	WORD IN;        	/* Interrupt number */
	WORD DR[8];     	/* Data Registers */
	WORD AC;        	/* Accumulateur */
	INST RI;        	/* Registre instruction */
} PSW;

#define MAX_PROCESS	(20) /* nb maximum de procssus */

#define EMPTY	(0) /* Processus non-pret */
#define READY	(1) /* Processus pret */

struct {
	PSW cpu;			/* mot d'état du processus */
	int state;			/* etat du processus */
} process[MAX_PROCESS]; /* table des processus */

int current_process = -1;	/* numero du processus courant */

/**********************************************************
** Simulation de la CPU (mode utilisateur)
***********************************************************/

/* instruction d'addition */
PSW cpu_ADD(PSW m) {
	m.AC = m.DR[m.RI.i] += (m.DR[m.RI.j] + m.RI.ARG);
	m.PC += 1;
	return m;
}

/* instruction de soustraction */
PSW cpu_SUB(PSW m) {
	m.AC = m.DR[m.RI.i] -= (m.DR[m.RI.j] + m.RI.ARG);
	m.PC += 1;
	return m;
}

/* instruction de comparaison */
PSW cpu_CMP(PSW m) {
	m.AC = (m.DR[m.RI.i] - (m.DR[m.RI.j] + m.RI.ARG));
	m.PC += 1;
	return m;
}

/* instruction de modification de PC */
PSW cpu_IFGT(PSW m) {
    if(m.AC > 0)
        m.PC = m.RI.ARG;
    else
		m.PC = m.PC + 1;

    return m;
}

/* instruction qui fait rien */
PSW cpu_NOP(PSW m) {
	m.PC = m.PC + 1;
    return m;
}

PSW cpu_JUMP(PSW m) {
    m.PC = m.RI.ARG;
    return m;
}

void cpu_HALT(PSW m) {
    printf("Halt....\n");
    exit(0);
}

PSW cpu_SYSC(PSW m) {
	m.IN = INT_SYSC;
	m.PC = m.PC + 1;
	
	return m;
}

PSW cpu_LOAD(PSW m) {
	m.AC = m.RI.j + m.RI.ARG;
	if(m.AC < 0 || m.AC >= m.SS)
		m.IN = INT_SEGV;
	else {
		m.AC = mem[m.SB + m.AC];
		m.DR[m.RI.i] = m.AC;
		m.PC = m.PC + 1;
	}
	
	return m;
}

PSW cpu_STORE(PSW m) {
	m.AC = m.RI.j + m.RI.ARG;
	if(m.AC < 0 || m.AC >= m.SS)
		m.IN = INT_SEGV;
	else {
		mem[m.SB + m.AC] = m.DR[m.RI.i];
		m.AC = m.DR[m.RI.i];
		m.PC = m.PC + 1;
	}
	
	return m;
}

/* Simulation de la CPU */
PSW cpu(PSW m) {
	union { WORD word; INST in; } inst;
	
	/*** lecture et decodage de l'instruction ***/
	if (m.PC < 0 || m.PC >= m.SS) {
		m.IN = INT_SEGV;
		return (m);
	}
	inst.word = mem[m.PC + m.SB];
	m.RI = inst.in;
	/*** execution de l'instruction ***/
	switch (m.RI.OP) {
	case INST_ADD:
		m = cpu_ADD(m);
		break;
	case INST_SUB:
		m = cpu_SUB(m);
		break;
	case INST_CMP:
		m = cpu_CMP(m);
		break;
	case INST_IFGT:
	    m = cpu_IFGT(m);
	    break;
	case INST_NOP:
	    m = cpu_NOP(m);
	    break;
	case INST_JUMP:
	    m = cpu_JUMP(m);
	    break;
	case INST_HALT:
	    cpu_HALT(m);
	    break;
	case INST_SYSC:
		m = cpu_SYSC(m);
		break;
	case INST_LOAD:
		m = cpu_LOAD(m);
		break;
	case INST_STORE:
		m = cpu_STORE(m);
		break;
	default:
		/*** interruption instruction inconnue ***/
		m.IN = INT_INST;
		return (m);
	}

	/*** interruption apres chaque instruction ***/
	
	nbInst = nbInst + 1;

	if(nbInst%3 != 0)
		m.IN = INT_CLOCK;
/*
	if(nbInst%3 == 0)
		m.IN = INT_TRACE;
	else
		m.IN = INT_CLOCK;
*/
	return m;
}


/**********************************************************
** Demarrage du systeme
***********************************************************/

PSW systeme_init(void) {
	PSW cpu;

	printf("Booting.\n");
	/*** creation d'un programme ***/

	int i = 0;
	
	while(i < MAX_PROCESS) {
		process[i].state = EMPTY;
		i = i + 1;
	}
	
	// make_inst(0, INST_SUB, 2, 2, -1000); /* R2 -= R2-1000 */
	// make_inst(1, INST_ADD, 1, 2, 500);   /* R1 += R2+500 */
	// make_inst(2, INST_ADD, 0, 2, 200);   /* R0 += R2+200 */
	// make_inst(3, INST_ADD, 0, 1, 100);   /* R0 += R1+100 */

	make_inst(0, INST_SUB, 1, 1, 0);		/* 1  : R1 = 0 */
	make_inst(1, INST_SUB, 2, 2, -1000);    /* 2  : R2 = 1000 */
	make_inst(2, INST_SUB, 3, 3, -10);      /* 3  : R3 = 10 */
	make_inst(3, INST_CMP, 1, 2, 0);        /* 4  : AC = (R1 - R2) */
	make_inst(4, INST_IFGT, 0, 0, 9);      	/* 4  : if (AC > 0) PC = 10 */
    make_inst(5, INST_NOP, 0, 0, 0);        /* 5  : no operation */
    make_inst(6, INST_SYSC, 1, 1, SYSC_NEW_THREAD);        /* 6  : no operation */ 
    make_inst(7, INST_NOP, 0, 0, 0);        /* 7  : no operation */
    make_inst(8, INST_ADD, 1, 3, 0);        /* 8  : R1 += R3 */
    make_inst(9, INST_JUMP, 0, 0, 3);       /* 9  : PC = 3 */
    make_inst(10, INST_HALT, 0, 0, 0);      /* 10 : HALT */

    // make_inst(4, INST_UNKNOW, 0, 3, 100); /* Unknow Instruction */
    
	/*** valeur initiale du PSW ***/
	memset (&cpu, 0, sizeof(cpu));
	cpu.PC = 0;
	cpu.SB = 0;
	cpu.SS = 20;
	
	process[0].cpu = cpu;
	process[0].state = READY;
	
	process[1].cpu = cpu;
	process[1].state = READY;
	
	current_process = 0;
	
	return cpu;
}


/**********************************************************
** Simulation du systeme (mode systeme)
***********************************************************/

PSW systeme(PSW m) {
	switch (m.IN) {
		case INT_INIT:
		    printf("%d -- INT_INIT received.\n", m.IN);
		    process[0].cpu = m;
		    process[0].state = READY;
			
			{
				int i = 1;
				while(i < MAX_PROCESS) {
					process[i].state = EMPTY;
					i = i + 1;
				}
			}
		    
		    current_process = 0;
			return (systeme_init());
		case INT_SEGV:
		    printf("%d -- INT_SEGV received.\n", m.IN);
		    exit(-1);
			break;
		case INT_TRACE:
		    printf("%d -- INT_TRACE received.\n", m.IN);
		    printf("PC : %d\n", m.PC);
		    int i = 0;
		    while(i < 8) {
		        printf("DR[%d] : %d\n", i, m.DR[i]);
			    i++;
			}
			break;
		case INT_INST:
		    printf("%d -- INT_INST received.\n", m.IN);
		    exit(-1);
			break;
		case INT_CLOCK:
			printf("%d -- INT_CLOCK received.\n", m.IN);
			if(current_process != -1) {
				process[current_process].cpu = m;
				process[current_process].state = READY;
			}
			
			do {
				current_process = (current_process + 1) % MAX_PROCESS;
			} while(process[current_process].state != READY);
			
			printf("-- Processus choisie : %d, RI = %d\n", current_process, m.RI.ARG);
			return process[current_process].cpu;
			break;
		case INT_SYSC:
			switch(m.RI.ARG) {
				case SYSC_EXIT:
					printf("Exit....\n");
					process[current_process].state = EMPTY;
					do {
						current_process = (current_process + 1) % MAX_PROCESS;
					} while(process[current_process].state != READY);
					return process[current_process].cpu;
				case SYSC_PUTI:
					printf("%d\n", m.DR[m.RI.i]);
					m.PC = m.PC + 1;
					break;
				case SYSC_NEW_THREAD:
				{
					// Simuler la gestion de thread
					int i = current_process;
					int nbProcess = 0;
				
					while(process[i % MAX_PROCESS].state != EMPTY && nbProcess != MAX_PROCESS) {
						i = i + 1;
						nbProcess = nbProcess + 1;
					}
					
					// L'indice du futur nouveau processus
					m.AC = i;
					m.DR[m.RI.i] = i;
					m.PC = m.PC + 1;
					
					process[i].state = READY;
					process[i].cpu = m;
					process[i].cpu.AC = 0;
				}
					break;
				case SYSC_SLEEP:
				case SYSC_GETCHAR:
				case SYSC_FORK:
				default :
					m.IN = INT_INST;
					break;
			}
		}
	
	sleep(1);
	
	return m;
}


/**********************************************************
** fonction principale
** (ce code ne doit pas etre modifie !)
***********************************************************/

int main(void) {
	PSW mep;
	
	mep.IN = INT_INIT; /* interruption INIT */	
	while (1) {
		mep = systeme(mep);
		mep = cpu(mep);
	}
	
	return (EXIT_SUCCESS);
}

