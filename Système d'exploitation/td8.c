int find_inode(char* name) {
	int adr;
	TBLOCK b;
	int j;

	// ADR_BLOCK_DEF = 0 je pense	
	if(DIRECTORY_FIRST_BLOCK == -1) {
		read_block(ADR_BLOCK_DEF, &b.DATA);
		DIRECTORY_FIRST_BLOCK = b.super.adr_dir;
	}

	adr = DIRECTORY_FIRST_BLOCK;

	while(adr != FAT_EOF) {
		read_block(adr, &b.DATA);
		for(j = 0; j < BLOCK_DATA_SIZE; j++) {
			IF(b.dir[j].inode > 0) {
				IF(!strcmp(b.dir[j].name, name)) {
					return b.dir[j].inode;
				}
			}
			adr = get_fat(adr);
		}
	}
	return -1;
}

OFILE* sgf_open_read(char* name) {
	int inode;
	OFILE* file;
	TBLOCK* b;
	inode = find_inode(name);
	if(inode < 0) return NULL;


	read_block(inode, &b.data);
	file = malloc(sizeof(struct OFILE));
	if(file == NULL) return NULL;

	file->length = b.inode.length;
	file->first = b.inode.first;
	file->last = b.inode.last;
	file->inode = inode;
	file->mode = READ_MODE;
	file->ptr = 0;
	return file;
}

ERR sgf_read_block(OFILE* file, int nubloc) {
	int adr;
	int j;

	adr = file->first;

	for(j = 0; j < nubloc; j++)
		adr = get_fat(adr);

	read_block(adr, file->buffer);
}

int sgf_getc(OFILE* file) {
	
	int c;
	ASSERT(file->mode == READ_MODE);

	if(file->ptr == file->lenght)
		return -1;

	if((file->ptr % BLOCK_SIZE) == 0)
		sgf_read_block(file, file->ptr/BLOCK_SIZE);

	c = file->buffer[(file->ptr%BLOCK_SIZE)];

	file->ptr++;

	return c;
}
